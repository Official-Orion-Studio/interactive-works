{"searchDocs":[{"title":"Singleton","type":0,"sectionRef":"#","url":"/interactive-works/api/Singleton","content":"","keywords":"","version":null},{"title":"Types​","type":1,"pageTitle":"Singleton","url":"/interactive-works/api/Singleton#types","content":" ","version":null,"tagName":"h2"},{"title":"SingletonConfig​","type":1,"pageTitle":"Singleton","url":"/interactive-works/api/Singleton#SingletonConfig","content":"&lt;/&gt; interface SingletonConfig { name: string, loadOrder?: number, constructor?: () → (), onInit?: (servicesBag) → (), onStart?: () → (), onTick?: (dt: number) → (), onPhysics?: (dt: number) → (), onRender?: (dt: number) → (), } Represents a singleton's configuration. ","version":null,"tagName":"h3"},{"title":"Functions​","type":1,"pageTitle":"Singleton","url":"/interactive-works/api/Singleton#functions","content":" ","version":null,"tagName":"h2"},{"title":"create​","type":1,"pageTitle":"Singleton","url":"/interactive-works/api/Singleton#create","content":"&lt;/&gt; Singleton.create( config: SingletonConfig-- The singleton's config. ) → SingletonConfig Checks and registers a singleton. Making sure to bind its lifecycles as well. Lifecycle methods are methods that are called at a specific time during the singleton's lifecycle, and these are called by another singletons that may have setup such lifecycles. All lifecycles should start with on..., as it's currently the only way to differentiate from methods. local singleton = { name = &quot;Singleton&quot;, onInit = function(self, servicesBag) ... end, onStart = function(self) ... end, onLifecycle = function(self) ... -- This will be called sometime in execution. end }   ","version":null,"tagName":"h3"},{"title":"get​","type":1,"pageTitle":"Singleton","url":"/interactive-works/api/Singleton#get","content":"&lt;/&gt; Singleton.get(key: string) → SingletonConfig Returns a singleton by its name. If the singleton hasn't been initialized, it will be initialized and returned.  ","version":null,"tagName":"h3"},{"title":"createService​","type":1,"pageTitle":"Singleton","url":"/interactive-works/api/Singleton#createService","content":"This item only works when running on the server. Server &lt;/&gt; Singleton.createService(config: SingletonConfig) → SingletonConfig Creates a service on the server.  ","version":null,"tagName":"h3"},{"title":"createController​","type":1,"pageTitle":"Singleton","url":"/interactive-works/api/Singleton#createController","content":"This item only works when running on the client. Client &lt;/&gt; Singleton.createController(config: SingletonConfig) → SingletonConfig Creates a controller on the client.  ","version":null,"tagName":"h3"},{"title":"getService​","type":1,"pageTitle":"Singleton","url":"/interactive-works/api/Singleton#getService","content":"This item only works when running on the server. Server &lt;/&gt; Singleton.getService(key: string) → SingletonConfig Returns a service by its name. This method should only be called by the server.  ","version":null,"tagName":"h3"},{"title":"getController​","type":1,"pageTitle":"Singleton","url":"/interactive-works/api/Singleton#getController","content":"This item only works when running on the client. Client &lt;/&gt; Singleton.getController(key: string) → SingletonConfig Returns a controller by its name. ","version":null,"tagName":"h3"},{"title":"Interactive","type":0,"sectionRef":"#","url":"/interactive-works/api/Interactive","content":"","keywords":"","version":null},{"title":"Properties​","type":1,"pageTitle":"Interactive","url":"/interactive-works/api/Interactive#properties","content":" ","version":null,"tagName":"h2"},{"title":"modding​","type":1,"pageTitle":"Interactive","url":"/interactive-works/api/Interactive#modding","content":"&lt;/&gt; Interactive.modding: Modding Interactive also provides a way to interact with the modding utility.  ","version":null,"tagName":"h3"},{"title":"util​","type":1,"pageTitle":"Interactive","url":"/interactive-works/api/Interactive#util","content":"&lt;/&gt; Interactive.util: Utility Interactive also provides a util library for common utility functions. ","version":null,"tagName":"h3"},{"title":"Functions​","type":1,"pageTitle":"Interactive","url":"/interactive-works/api/Interactive#functions","content":" ","version":null,"tagName":"h2"},{"title":"init​","type":1,"pageTitle":"Interactive","url":"/interactive-works/api/Interactive#init","content":"&lt;/&gt; Interactive.init() → nil Initializes the library, allowing you to create services, controllers, and components. This stage is the most important, since it will be constructing services, controllers, and components based on the structure you've defined. DANGER This method MUST be called before any other method in the library and only ONCE throughout the environment (server and client).  ","version":null,"tagName":"h3"},{"title":"addPath​","type":1,"pageTitle":"Interactive","url":"/interactive-works/api/Interactive#addPath","content":"&lt;/&gt; Interactive.addPath(path: string) → nil Adds a path where the library will look for services, controllers, and components. This method should be called before Interactive.init().  ","version":null,"tagName":"h3"},{"title":"setLogLevel​","type":1,"pageTitle":"Interactive","url":"/interactive-works/api/Interactive#setLogLevel","content":"&lt;/&gt; Interactive.setLogLevel(level: &quot;top-level&quot; | &quot;verbose&quot;) → nil Sets the log level of the Interactive framework. There's internal debugging and this function determinates how much debugging should be shown.  ","version":null,"tagName":"h3"},{"title":"createService​","type":1,"pageTitle":"Interactive","url":"/interactive-works/api/Interactive#createService","content":"This item only works when running on the server. Server &lt;/&gt; Interactive.createService(config: SingletonConfig) → () Creates a service on the server.  ","version":null,"tagName":"h3"},{"title":"createController​","type":1,"pageTitle":"Interactive","url":"/interactive-works/api/Interactive#createController","content":"This item only works when running on the client. Client &lt;/&gt; Interactive.createController(config: SingletonConfig) → () Creates a controller on the client.  ","version":null,"tagName":"h3"},{"title":"getService​","type":1,"pageTitle":"Interactive","url":"/interactive-works/api/Interactive#getService","content":"This item only works when running on the server. Server &lt;/&gt; Interactive.getService(key: string) → () Returns a service by its name. This method should only be called by the server.  ","version":null,"tagName":"h3"},{"title":"getController​","type":1,"pageTitle":"Interactive","url":"/interactive-works/api/Interactive#getController","content":"This item only works when running on the client. Client &lt;/&gt; Interactive.getController(key: string) → () Returns a controller by its name.  ","version":null,"tagName":"h3"},{"title":"createComponent​","type":1,"pageTitle":"Interactive","url":"/interactive-works/api/Interactive#createComponent","content":"&lt;/&gt; Interactive.createComponent(component: ComponentConfig) → Component Creates a component based on the structure defined. Returns a component object. ","version":null,"tagName":"h3"},{"title":"Modding","type":0,"sectionRef":"#","url":"/interactive-works/api/Modding","content":"","keywords":"","version":null},{"title":"Functions​","type":1,"pageTitle":"Modding","url":"/interactive-works/api/Modding#functions","content":" ","version":null,"tagName":"h2"},{"title":"preload​","type":1,"pageTitle":"Modding","url":"/interactive-works/api/Modding#preload","content":"&lt;/&gt; Modding.preload( module: ModuleScript -- The module to preload. ) → SingletonConfig Preloads a module and returns the constructed object.  ","version":null,"tagName":"h3"},{"title":"registerSingleton​","type":1,"pageTitle":"Modding","url":"/interactive-works/api/Modding#registerSingleton","content":"&lt;/&gt; Modding.registerSingleton( ctor: any,-- The constructed object module?: ModuleScript? -- An optional module from where the source is coming from. ) → nil Registeres a singleton into the Modding module.  ","version":null,"tagName":"h3"},{"title":"registerComponent​","type":1,"pageTitle":"Modding","url":"/interactive-works/api/Modding#registerComponent","content":"&lt;/&gt; Modding.registerComponent( ctor: any,-- The constructed object module?: ModuleScript -- An optional module from where the source is coming from. ) → nil Registers a component into the Modding module.  ","version":null,"tagName":"h3"},{"title":"getDeferredConstructor​","type":1,"pageTitle":"Modding","url":"/interactive-works/api/Modding#getDeferredConstructor","content":"&lt;/&gt; Modding.getDeferredConstructor( ctor: SingletonConfig-- The constructor to bind. ) → () Constructs a new binding to a deferred constructor. NOTE This is only used in components at the moment.  ","version":null,"tagName":"h3"},{"title":"getSingletons​","type":1,"pageTitle":"Modding","url":"/interactive-works/api/Modding#getSingletons","content":"&lt;/&gt; Modding.getSingletons() → {SingletonConfig}-- All singletons. Returns all the registered singletons so far.  ","version":null,"tagName":"h3"},{"title":"getSingleton​","type":1,"pageTitle":"Modding","url":"/interactive-works/api/Modding#getSingleton","content":"&lt;/&gt; Modding.getSingleton( id: string-- The id of the singleton. ) → SingletonConfig-- The singleton. Returns a singleton by its id.  ","version":null,"tagName":"h3"},{"title":"addListener​","type":1,"pageTitle":"Modding","url":"/interactive-works/api/Modding#addListener","content":"&lt;/&gt; Modding.addListener( ctor: any,-- The constructor to bind. lifecycleId: string-- The lifecycle id to listen against. ) → nil Adds a new listener for the given lifecycle.  ","version":null,"tagName":"h3"},{"title":"onListenerAdded​","type":1,"pageTitle":"Modding","url":"/interactive-works/api/Modding#onListenerAdded","content":"&lt;/&gt; Modding.onListenerAdded( fn: (any) → any,-- The function to bind. id: string-- The id to listen against. ) → ConnectionLike ","version":null,"tagName":"h3"},{"title":"Types","type":1,"pageTitle":"Modding","url":"/interactive-works/api/Modding##","content":"","version":null,"tagName":"h3"},{"title":"​","type":1,"pageTitle":"Modding","url":"/interactive-works/api/Modding#ConnectionLike","content":"interface ConnectionLike { disconnect: () → nil-- Disconnects the connection. connected: boolean-- Whether the connection is connected or not. }  Used for metadata listeners, mostly for lifecycle events. But it can be used to hear for other listeners. ","version":null,"tagName":"h3"},{"title":"Utility","type":0,"sectionRef":"#","url":"/interactive-works/api/Utility","content":"","keywords":"","version":null},{"title":"Functions​","type":1,"pageTitle":"Utility","url":"/interactive-works/api/Utility#functions","content":" ","version":null,"tagName":"h2"},{"title":"setupLifecycle​","type":1,"pageTitle":"Utility","url":"/interactive-works/api/Utility#setupLifecycle","content":"&lt;/&gt; Utility.setupLifecycle( t: {any},-- The listeners table. lifecycle: string-- The lifecycle to listen for. ) → () Set ups a lifecycle for a given array of listeners data.  ","version":null,"tagName":"h3"},{"title":"initLifecycle​","type":1,"pageTitle":"Utility","url":"/interactive-works/api/Utility#initLifecycle","content":"&lt;/&gt; Utility.initLifecycle( t: {any},-- The object to initialize the lifecycle for. lifecycle: string,-- The lifecycle to initialize. ...: U...-- The arguments to pass to the function. ) → () Initializes a lifecycle for a given function. ","version":null,"tagName":"h3"},{"title":"Lifecycles","type":0,"sectionRef":"#","url":"/interactive-works/docs/core/lifecycles","content":"","keywords":"","version":"Next"},{"title":"onInit​","type":1,"pageTitle":"Lifecycles","url":"/interactive-works/docs/core/lifecycles#oninit","content":" The onInit lifecycle is the first step on initializing a singleton/component, it's also where we expose a servicesBag where you can retrieve services from (for now). This method doesn't yield and lifecycles aren't affected between each other.  ","version":"Next","tagName":"h2"},{"title":"onStart​","type":1,"pageTitle":"Lifecycles","url":"/interactive-works/docs/core/lifecycles#onstart","content":" The onStart lifecycle is the stage where all services are expected to be on an initialized state. This method doesn't yield and lifecycles aren't affected between each other.  ","version":"Next","tagName":"h2"},{"title":"onTick​","type":1,"pageTitle":"Lifecycles","url":"/interactive-works/docs/core/lifecycles#ontick","content":" This is a lifecycle exposed to all singletons and components, directly binded to RunService.Heartbeat.  ","version":"Next","tagName":"h2"},{"title":"onPhysics​","type":1,"pageTitle":"Lifecycles","url":"/interactive-works/docs/core/lifecycles#onphysics","content":" This is a lifecycle exposed to all singletons and components, directly binded to RunService.PreSimulation.  ","version":"Next","tagName":"h2"},{"title":"onRender​","type":1,"pageTitle":"Lifecycles","url":"/interactive-works/docs/core/lifecycles#onrender","content":" This is a lifecycle exposed to all singletons and components, directly binded to RunService.PreRender.  warning This lifecycle can only be binded on the client, if there's a service that may include, it will throw. ","version":"Next","tagName":"h2"},{"title":"Components","type":0,"sectionRef":"#","url":"/interactive-works/api/Components","content":"","keywords":"","version":null},{"title":"Types​","type":1,"pageTitle":"Components","url":"/interactive-works/api/Components#types","content":" ","version":null,"tagName":"h2"},{"title":"ComponentConfig​","type":1,"pageTitle":"Components","url":"/interactive-works/api/Components#ComponentConfig","content":"&lt;/&gt; interface ComponentConfig { tag: string, defaults?: {[string]: any}?, instanceGuard?: (instance: Instance ) → boolean, ancestors: {Instance }?, ignoreFlags: boolean? constructor?: () → (), onStart?: (singletonsBag: any) → (), onAttributeChanged?: ( attribute: string, value: any ) → (), onTick?: (dt: number) → (), onPhysics?: (dt: number) → (), onRender?: (dt: number) → (), } The interface for a ComponentConfig. The initial state of a component.  ","version":null,"tagName":"h3"},{"title":"Component​","type":1,"pageTitle":"Components","url":"/interactive-works/api/Components#Component","content":"&lt;/&gt; interface Component { instance: Instance -- The instance of the component. attributes: {[string]: any}-- The attributes of the component. } The interface for a Component. ","version":null,"tagName":"h3"},{"title":"Functions​","type":1,"pageTitle":"Components","url":"/interactive-works/api/Components#functions","content":" ","version":null,"tagName":"h2"},{"title":"addComponent​","type":1,"pageTitle":"Components","url":"/interactive-works/api/Components#addComponent","content":"&lt;/&gt; Components:addComponent( instance: Instance ,-- The instance to add the component to. ctor: ComponentConfig-- The component's constructor. ) → () Adds a component to an instance linked by the created object. This will register the component, start its lifecycles, bind callbacks to the required listeners and setup their attributes and properties. NOTE This function can be called upon a component that is yet to be registered, though it is not recommended. Best practice is to rely on framework.createComponent, as it is guaranteed to initialize the component correctly. This method should only be used for debugging purposes when isolating a single component.  ","version":null,"tagName":"h3"},{"title":"setupComponent​","type":1,"pageTitle":"Components","url":"/interactive-works/api/Components#setupComponent","content":"&lt;/&gt; Components:setupComponent( instance: Instance ,-- The instance to add the component to. attributes: {[string]: any},-- The attributes of the instance. component: ComponentConfig,-- The component to setup. construct: () → ()-- The constructor of the component, sometimes this may be a deferred constructor. ) → () Setups a component, finally running its lifecycles and constructing it with the given instance. In the most raw form, this function is responsible for setting up a component and running its lifecycle methods. Can be used to quickly debug a component structure. local frameworkComponents = require(...) local component = {} function component:constructor() print(&quot;Hello, world!&quot;) end function component:onStart() print(&quot;I have started!&quot;) end frameworkComponents:setupComponent(&lt;Instance&gt;, { ... }, component, function() component:constructor() end) WARNING You should not call this function directly, instead, use framework.createComponent. ","version":null,"tagName":"h3"},{"title":"Installation","type":0,"sectionRef":"#","url":"/interactive-works/docs/installation","content":"","keywords":"","version":"Next"},{"title":"Installing Interactive​","type":1,"pageTitle":"Installation","url":"/interactive-works/docs/installation#installing-interactive","content":" First off you'll want install the interactive framework. For this, you would need to modify your wally.toml as next:  /wally.toml [dependencies] interactive = &quot;siriuslatte/interactiveworks@version&quot;   And run the next command on your terminal (at your project's root).  wally install   ","version":"Next","tagName":"h3"},{"title":"Accessing Interactive​","type":1,"pageTitle":"Installation","url":"/interactive-works/docs/installation#accessing-interactive","content":" For those who may not be familiar with wally. The way to access the framework will be as shown below:  src/server/runtime.luau local ReplicatedStorage = game:GetService(&quot;ReplicatedStorage&quot;) local framework = require(ReplicatedStorage.Packages.interactive) framework.addPath(script.Parent) framework.init()   The script shows the most simple way of adding the whole server folder into the execution lifecycle of Interactive. ","version":"Next","tagName":"h3"},{"title":"Singletons","type":0,"sectionRef":"#","url":"/interactive-works/docs/core/singletons","content":"","keywords":"","version":"Next"},{"title":"Lifecycles​","type":1,"pageTitle":"Singletons","url":"/interactive-works/docs/core/singletons#lifecycles","content":" Singletons (and later on Components) can implement lifecycles themselves. The main lifecycles are onInit and onStart.  info All lifecycles should start with the on word, this is the only way (as of right now) that lifecycles will be registered for services implementing them.  The way to implement custom-made lifecycles is via the modding library. Which will be revisited on a later chapter.  For the next example though, we are going to be using the utility library so we can implement an onPlayerAdded lifecycle as shown below  src/server/services/first.luau local Players = game:GetService(&quot;Players&quot;) local framework = require(...) local utility = framework.utility local firstService = { name = &quot;firstService&quot; } function firstService:constructor() self.addedSignals = {} end function firstService:onStart() utility.setupLifecycle(self.addedSignals, &quot;onPlayerAdded&quot;) Players.PlayerAdded:Connect(function(player) utility.initLifecycle(self.addedSignals, &quot;onPlayerJoin&quot;, player) end) end return framework.createService(firstService)   And another service can use it:  src/server/services/second.luau local framework = require(...) local secondService = { name = &quot;secondService&quot; } function secondService:onPlayerAdded(player: Player) print(player .. &quot; has joined the game!&quot;) end return framework.createService(secondService)   Have in mind that it doesn't matter if secondService is resolved first than firstService, lifecycles are binded if there's not a listener at the moment is resolved. ","version":"Next","tagName":"h2"},{"title":"Introduction","type":0,"sectionRef":"#","url":"/interactive-works/docs/intro","content":"","keywords":"","version":"Next"},{"title":"Why does this exists?​","type":1,"pageTitle":"Introduction","url":"/interactive-works/docs/intro#why-does-this-exists","content":" This may be a good question to start with. Interactive has been designed to ease how we make games here at Orion Studios. Throught development of our first experience we saw the urge to change to an actual framework which could provide us a centralized functionality.  For this reason, Interactive was born. And we would like to give you a warm welcome into it.  tip Thanks to flamework for being such a great inspiration on Interactive!  ","version":"Next","tagName":"h2"},{"title":"Structure​","type":1,"pageTitle":"Introduction","url":"/interactive-works/docs/intro#structure","content":" Interactive exposes a structure which may be familiar to almost all developers in the platform, which are Singletons and Components. If you haven't, we invite you over to read about them and come back to this document once you have made your research.  ","version":"Next","tagName":"h3"},{"title":"Example​","type":1,"pageTitle":"Introduction","url":"/interactive-works/docs/intro#example","content":" Creating a new singleton/component is as easy as defining the object and calling Interactive.create...(). Here's an example:  src/server/services/service.luau local framework = ... local service = { name = &quot;MyService&quot; } return framework.createService(service)  ","version":"Next","tagName":"h2"},{"title":"Components","type":0,"sectionRef":"#","url":"/interactive-works/docs/core/components","content":"","keywords":"","version":"Next"},{"title":"Declaring a component​","type":1,"pageTitle":"Components","url":"/interactive-works/docs/core/components#declaring-a-component","content":" Components have a variety of useful fields which Singletons don't expose. But every single component requires to have at least a tag, everything else is optional.  src/server/components/component.luau local framework = require(...) local component = { tag = &quot;MyTag&quot;, } function component:onStart(singletonsBag) ... end function component:destroy() ... end return framework.createComponent(component)   This is the basic boilerplate required to construct a component. Components can also have a constructor where they define inner elements for it's functionality.  ","version":"Next","tagName":"h2"},{"title":"Configuration​","type":1,"pageTitle":"Components","url":"/interactive-works/docs/core/components#configuration","content":" Components have a vast majority of configuration, this is to open the possibility to either delimit, or expand the functionality of your Component.  The next properties can be added to the initial Component.  defaults​  They describe default attributes for your Instance to have.  The next example demonstrates a component which will have an example attribute of value Vector.zero.  { defaults = { example = Vector3.zero, }, }   instanceGuard​  A function that takes the instance being added and SHOULD return a boolean. It should be used to verify the tree of your instance if you require so. For example, a character component, the instanceGuard could be useful to look into it and try to find a Humanoid.  The next example demonstrates a component which is only constructed when the instance is a Model.  { instanceGuard = function(instance: Instance) return instance:IsA(&quot;Model&quot;) end, }   ancestors​  An Instance list which is verified against to construct the component. If the Instance tagged isn't a descendant of ANY of the provided paths, it will throw.  The next example demonstrates a component which is only constructed when the Instance is a descendant of Workspace.  { ancestors = { Workspace }, }   ignoreFlags​  A boolean which describes if the flags should be ignored. This applies to errors while constructing the Component, or ancestors issues, even instanceGuard flags will be ignored.  danger This property should be avoided, use only if necessary.  ","version":"Next","tagName":"h3"},{"title":"Constructed component​","type":1,"pageTitle":"Components","url":"/interactive-works/docs/core/components#constructed-component","content":" A constructed component is what you use within the object itself, and it exposes two properties and a lifecycle which is useful to manipulate the Instance.  instance​  The Instance which was tagged can be accessed from here. It should be the only way of accessing such Instance.  The next example prints the full name (path) of the Instance tagged.  function &lt;component&gt;:onStart() print(`I was tagged with {self.tag} and my path is {self.instance:GetFullName()}`) end   attributes​  This is an object which can be accessed at any time, and it's updated through the Component's life. Accessing attributes from here is preferred over self.instance:GetAttribute(), as the latter is inconvinient.  The next example prints all the attributes a component may have and also change an attribute!  function &lt;component&gt;:onStart() print(self.attributes) self.attributes.MyAttribute = &quot;A value that is replicated!&quot; end   onAttributeChanged​  This lifecycle is only available to Components. It exposes which attribute and it's new value.  The next example prints the changes on a component by its attributes.  function &lt;component&gt;:onAttributeChanged(attribute, value) print(attribute .. &quot; was changed. New value is: &quot;, value) end  ","version":"Next","tagName":"h3"}],"options":{"id":"default"}}